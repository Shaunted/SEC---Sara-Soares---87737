$date
	Mon Nov  4 17:06:58 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module xtop_tb $end
$var wire 32 ! r0 [31:0] $end
$var wire 32 " r1 [31:0] $end
$var wire 32 # r10 [31:0] $end
$var wire 32 $ r11 [31:0] $end
$var wire 32 % r12 [31:0] $end
$var wire 32 & r13 [31:0] $end
$var wire 32 ' r14 [31:0] $end
$var wire 32 ( r15 [31:0] $end
$var wire 32 ) r2 [31:0] $end
$var wire 32 * r3 [31:0] $end
$var wire 32 + r4 [31:0] $end
$var wire 32 , r5 [31:0] $end
$var wire 32 - r6 [31:0] $end
$var wire 32 . r7 [31:0] $end
$var wire 32 / r8 [31:0] $end
$var wire 32 0 r9 [31:0] $end
$var wire 1 1 trap $end
$var wire 1 2 led $end
$var reg 1 3 clk $end
$var reg 1 4 rst $end
$var integer 32 5 k [31:0] $end
$var integer 32 6 start_time [31:0] $end
$scope module uut $end
$var wire 1 3 clk $end
$var wire 1 4 rst $end
$var wire 1 1 trap $end
$var wire 1 7 regf_sel $end
$var wire 32 8 regf_data_to_rd [31:0] $end
$var wire 9 9 pc [8:0] $end
$var wire 1 : mem_sel $end
$var wire 32 ; mem_data_to_rd [31:0] $end
$var wire 1 < led_sel $end
$var wire 1 2 led $end
$var wire 32 = instruction [31:0] $end
$var wire 1 > data_we $end
$var wire 32 ? data_to_wr [31:0] $end
$var wire 32 @ data_to_rd [31:0] $end
$var wire 1 A data_sel $end
$var wire 10 B data_addr [9:0] $end
$var wire 1 C cprt_sel $end
$scope module addr_decoder $end
$var wire 1 A sel $end
$var wire 32 D regf_data_to_rd [31:0] $end
$var wire 32 E mem_data_to_rd [31:0] $end
$var wire 10 F addr [9:0] $end
$var reg 1 C cprt_sel $end
$var reg 32 G data_to_rd [31:0] $end
$var reg 1 < led_sel $end
$var reg 1 : mem_sel $end
$var reg 1 7 regf_sel $end
$var reg 1 1 trap_sel $end
$upscope $end
$scope module controller $end
$var wire 1 H alu_arith_ops $end
$var wire 1 I alu_imm_ops $end
$var wire 1 J alu_logic_ops $end
$var wire 1 K alu_mem_ops $end
$var wire 1 L alu_ops $end
$var wire 32 M and_res [31:0] $end
$var wire 1 N branch_ops $end
$var wire 1 3 clk $end
$var wire 1 O imm_ops $end
$var wire 1 P load_imm_ops $end
$var wire 1 Q load_mem_ops $end
$var wire 1 R load_ops $end
$var wire 32 S mem_data_from [31:0] $end
$var wire 32 T mem_data_to [31:0] $end
$var wire 1 A mem_sel $end
$var wire 1 > mem_we $end
$var wire 1 4 rst $end
$var wire 1 U store_mem_ops $end
$var wire 32 V xor_res [31:0] $end
$var wire 4 W opcode [3:0] $end
$var wire 32 X instruction [31:0] $end
$var wire 32 Y imm [31:0] $end
$var reg 32 Z adder_res [31:0] $end
$var reg 1 [ alu_carry $end
$var reg 1 \ alu_negative $end
$var reg 1 ] alu_overflow $end
$var reg 32 ^ alu_result [31:0] $end
$var reg 1 _ carry_res_n $end
$var reg 32 ` carry_res_n_1 [31:0] $end
$var reg 10 a mem_addr [9:0] $end
$var reg 32 b operand [31:0] $end
$var reg 9 c pc [8:0] $end
$var reg 32 d regA [31:0] $end
$var reg 32 e regB [31:0] $end
$var reg 3 f regC [2:0] $end
$upscope $end
$scope module cprint $end
$var wire 1 3 clk $end
$var wire 8 g data_in [7:0] $end
$var wire 1 h sel $end
$upscope $end
$scope module ledprint $end
$var wire 1 3 clk $end
$var wire 1 i data_in $end
$var wire 1 4 rst $end
$var wire 1 < sel $end
$var reg 1 2 led $end
$upscope $end
$scope module ram $end
$var wire 1 3 clk $end
$var wire 9 j data_addr [8:0] $end
$var wire 9 k data_addr_int [8:0] $end
$var wire 1 l data_en_int $end
$var wire 32 m data_in [31:0] $end
$var wire 32 n data_in_int [31:0] $end
$var wire 32 o data_out [31:0] $end
$var wire 1 : data_sel $end
$var wire 1 > data_we $end
$var wire 1 p data_we_int $end
$var wire 1 q instr_en $end
$var wire 9 r pc [8:0] $end
$var reg 32 s data_out_int [31:0] $end
$var reg 32 t instruction [31:0] $end
$upscope $end
$scope module regf $end
$var wire 4 u addr [3:0] $end
$var wire 1 3 clk $end
$var wire 32 v data_in [31:0] $end
$var wire 1 7 sel $end
$var wire 1 > we $end
$var wire 32 w data_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx w
bx v
bx u
bx t
bx s
bx r
1q
xp
bx o
bx n
bx m
xl
bx k
bx j
xi
xh
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
x_
bx ^
x]
x\
x[
bx Z
bx Y
bx X
bx W
bx V
xU
bx T
bx S
xR
xQ
xP
xO
xN
bx M
xL
xK
xJ
xI
xH
bx G
bx F
bx E
bx D
xC
bx B
xA
bx @
bx ?
x>
bx =
x<
bx ;
x:
bx 9
bx 8
x7
bx 6
bx 5
04
13
x2
x1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#5000
03
#10000
13
#11000
0]
0\
0[
b0 ^
b0 Z
0_
b0 `
b0 V
b0 M
b0 g
0i
b0 b
b0 9
b0 c
b0 r
b0 n
b0 ?
b0 T
b0 m
b0 v
b0 d
b0 e
b0 f
14
#15000
03
#20000
0A
b0 8
b0 D
b0 w
b0 @
b0 G
b0 S
b1 Z
b1 `
b1 V
b1 u
b1 k
b1 j
0<
01
0C
07
0l
0:
b1 b
b1 B
b1 F
b1 a
0K
0L
0h
1R
1O
b1 Y
0N
0J
0H
0I
0p
0>
0U
0Q
1P
b110 W
b1100000000000000000000000000001 =
b1100000000000000000000000000001 X
b1100000000000000000000000000001 t
02
13
#21000
b10000 5
b10101 6
04
#25000
03
#30000
b10 Z
b10 `
b0 V
b1 M
b1 g
1i
b1 9
b1 c
b1 r
b1 n
b1 ?
b1 T
b1 m
b1 v
b1 d
13
#35000
03
#40000
1<
1A
b1 Z
b1 `
b1 V
b0 M
b0 u
b100000000 k
b100000000 j
b0 b
b1100000000 B
b1100000000 F
b1100000000 a
0R
0O
b1100000000 Y
1p
1>
1U
0P
b1001 W
b10 9
b10 c
b10 r
b10010000000000000000001100000000 =
b10010000000000000000001100000000 X
b10010000000000000000001100000000 t
13
#45000
03
#50000
0A
b0 @
b0 G
b0 S
b110110 Z
b110110 `
b110100 V
b1 M
b101 u
b110101 k
b110101 j
0l
0:
0<
b110101 b
b110101 B
b110101 F
b110101 a
1R
1O
b110101 Y
0p
0>
0U
1P
b110 W
b11 9
b11 c
b11 r
12
b1100000000000000000000000110101 =
b1100000000000000000000000110101 X
b1100000000000000000000000110101 t
13
#55000
03
#60000
11
1A
b1111 u
b111111111 k
b111111111 j
b0 b
b1111111111 B
b1111111111 F
b1111111111 a
0R
0O
b111111111111111 Y
1p
1>
1U
0P
b110101 Z
b110101 `
b110101 V
b0 M
b110101 g
b1001 W
b110101 n
b110101 ?
b110101 T
b110101 m
b110101 v
b110101 d
b100 9
b100 c
b100 r
b10010000000000000111111111111111 =
b10010000000000000111111111111111 X
b10010000000000000111111111111111 t
13
#65000
03
#70000
0A
b0 @
b0 G
b0 S
b0 u
b0 k
b0 j
0l
0:
01
b0 B
b0 F
b0 a
1R
1O
b0 Y
0p
0>
0U
1P
b110 W
b101 9
b101 c
b101 r
b1100000000000000000000000000000 =
b1100000000000000000000000000000 X
b1100000000000000000000000000000 t
13
