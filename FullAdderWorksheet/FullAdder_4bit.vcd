$date
	Mon Oct 21 16:11:48 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module FullAdder_tb $end
$var wire 4 ! s [3:0] $end
$var wire 1 " co $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % ci $end
$scope module uut $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % ci $end
$var wire 4 ( s [3:0] $end
$var wire 5 ) cout [4:0] $end
$var wire 1 " co $end
$scope begin genblk1[0] $end
$scope module full1 $end
$var wire 1 * axb $end
$var wire 1 + bita $end
$var wire 1 , bitb $end
$var wire 1 - ci $end
$var wire 1 . co $end
$var wire 1 / s $end
$upscope $end
$upscope $end
$scope begin genblk1[1] $end
$scope module full1 $end
$var wire 1 0 axb $end
$var wire 1 1 bita $end
$var wire 1 2 bitb $end
$var wire 1 3 ci $end
$var wire 1 4 co $end
$var wire 1 5 s $end
$upscope $end
$upscope $end
$scope begin genblk1[2] $end
$scope module full1 $end
$var wire 1 6 axb $end
$var wire 1 7 bita $end
$var wire 1 8 bitb $end
$var wire 1 9 ci $end
$var wire 1 : co $end
$var wire 1 ; s $end
$upscope $end
$upscope $end
$scope begin genblk1[3] $end
$scope module full1 $end
$var wire 1 < axb $end
$var wire 1 = bita $end
$var wire 1 > bitb $end
$var wire 1 ? ci $end
$var wire 1 @ co $end
$var wire 1 A s $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xA
x@
x?
0>
1=
1<
x;
x:
x9
08
17
16
x5
x4
x3
02
11
10
x/
x.
x-
0,
1+
1*
bx )
bx (
b10 '
b101 &
x%
b10 $
b101 #
x"
bx !
$end
#10000
05
0;
b0x !
b0x (
0A
03
09
0?
0"
0.
04
0:
b0x )
0@
0*
00
06
0<
0+
01
07
0=
b10 #
b10 &
#20000
